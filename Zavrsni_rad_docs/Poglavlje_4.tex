\chapter{Sudari, fizika i vanjske sile}
U ovom poglavlju, prije implementacije algoritma za podjelu prostora, prvo je potrebno opisati kakve će se uopće reakcije događati među kuglicama prilikom sudara. Potrebno je također i ograničiti našu scenu svojevrsnim zidovima. Vanjska sila je također važan dio ovoga projekta. Bilo je potrebno dodati gravitaciju na cijeloj sceni da se dobije dojam padanja kuglica i odbijanja od podloge. 

Potrebno je realizirati kretanje kuglica po sceni. Kretanja su definirana u pomoćnoj klasi \emph{Vector3D}. Pomoću ove klase također su definirane normale zidova. Ovakav pristup znatno je olakšao samo rješavanje sudara jer se izbjeglo korištenje kompliciranih trigonometrijskih jednadžbi i funkcija.\newpage

\section{Implementacija klase Vector 3D}\label{sec:vec3}

\begin{lstlisting}[style = myC++, label = {code:9}, caption={Implementacija klase Vector3D}]
class Vector3D {
public:
	Vector3D() = default;
	Vector3D(float x, float y, float z) {
		this->vec.emplace_back(x);
		this->vec.emplace_back(y);
		this->vec.emplace_back(z);
	}
	Vector3D(Point point) {
		this->vec.emplace_back(point.x);
		this->vec.emplace_back(point.y);
		this->vec.emplace_back(point.z);
	}
	Vector3D operator*(float const &scalar) {
		return Vector3D(this->x() * scalar, this->y() * scalar, this->z() * scalar);
	}
	Vector3D operator-(Vector3D &rhs) {
		return Vector3D(this->x() - rhs.x(), this->y() - rhs.y(),
		this->z() - rhs.z());
	}
	Vector3D normal() {
		float mag = std::sqrt(std::pow(this->x(), 2) + std::pow(this->y(), 2) +
		std::pow(this->z(), 2));
		if (mag == 0) {
			return Vector3D(1, 0, 0);
		}
		return Vector3D(this->x() / mag, this->y() / mag, this->z() / mag);
	}
	const float &x() const { return vec[0]; }
	const float &y() const { return vec[1]; }
	const float &z() const { return vec[2]; }
	void setX(const float &x) { vec[0] = x; 
	void setY(const float &y) { vec[1] = y; }
	void setZ(const float &z) { vec[2] = z; }

private:
	std::vector<float> vec;
};

inline float operator*(const Vector3D &lhs, const Vector3D &rhs) {
	return lhs.x() * rhs.x() + lhs.y() * rhs.y() + lhs.z() * rhs.z();
}

\end{lstlisting}
Ova klasa kako sadrži implementaciju najvažnijih vektorskih operacija:
\begin{itemize}
	\item Operator * će nam izračunati skalarni produkt između 2 vektora
	\item Funkcija $normalize$ će normalizirati vektor
\end{itemize}
Naravno, za same vektore postoji još niz operacija, no ovdje su nam za sada bile potrebne samo ove dvije. Postavljene su i \emph{Set} metode za postavljanje vrijednosti u koordinate vektora. Ova klasa je $header only$ i napisana je prema literaturi \cite{2}.

\section{Kretanje kuglica}
U ovom kratkom paragrafu objasniti ćemo kako se realiziralo kretanje kuglica po sceni. Kako je to objašnjeno u poglavlju \ref{sec:balls}, za kretanje smo koristili funkciju pod imenom \emph{updatePosition} koja je za argument primala broj \emph{dt} što u prijevodu znači $delta time$ ili razlika u vremenu između 2 framea. 
Brzinu kretanja kuglice definirali smo kao:
\begin{itemize}
	\item Brzina u X smjeru
	\item Brzina u Y smjeru
	\item Brzina u Z smjeru
\end{itemize}
Informacije o brzinama bile su spremljene u strukturi podataka \emph{Vector3D}, koju smo opisali u prethodnom paragrafu \ref{sec:vec3}. Kretanje kuglica definira se prema klasičnoj formuli iz mehanike:
\begin{equation}
		v = \frac{s}{t} \label{equ:brzina}
\end{equation}
gdje je:
\begin{itemize}
	\item v - brzina
	\item s - prijeđeni put
	\item t - vrijeme 
\end{itemize}
S obzirom da nama ne treba izračun brzine, nego nam je potreban put koji će kuglica prijeći u svakom trenutku, malom izmjenom i prilagodbom jednadžbe dobije se:
\begin{equation}\label{equ:put}
\begin{aligned}
	s_x = vector.x \ dt\\
	s_y = vector.y \ dt\\
	s_z = vector.z \ dt
	\end{aligned}
\end{equation}
gdje nam je:
\begin{itemize}
	\item $vector.(x,y,z)$ - brzina u danoj koordinati
	\item $s (x,y,z)$ - prijeđeni put u danoj koordinati
	\item $dt$ - razlika vremena između 2 framea
\end{itemize}
Na ovakav jednostavan način dobili smo kretanje kuglice u bilo kojem smjeru, za sad bez ikakve vanjske sile tj. gravitacije.
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
			\draw (0,0) circle (1.5);
			\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (0,0) to (2,0) node[minimum size = 1pt, xshift = 1.5 cm, yshift = -0.5cm]{Kretanje u X smjeru};
			\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (0,0) to (0,2) node[minimum size = 1pt, xshift = 0.5 cm, yshift = 0	.5cm]{Kretanje u Y smjeru};
			
			\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (0,0) to (2,2) node[minimum size = 1pt, xshift = 1.2 cm, yshift = -0.5cm]{Smjer kretanja};
			
		\end{tikzpicture}
	\end{center}
	\caption {Kretanje kuglica realizirano jednostavnim zbrajanjem vektora}
	\label{fig:14}
\end{figure}

Sada kada nam je jasno definirano kretanje kuglica, potrebno je definirati kako će se kuglice ponašati prilikom sudara. S obzirom da su nam sve informacije spremljene u vektoru, to ne bi smjelo predstavljati problem. Korištenjem jednostavnih formula iz mehanike može se vrlo jednostavno dobiti reakcija kuglice na sudar sa drugom kuglicom ili zidom.

\section{Sudari kuglica}

Sudari su općenito mogu podijeliti u 2 skupine:
\begin{itemize}
	\item Neelastične sudare
	\item Elastične sudare
\end{itemize}
Neelastični sudari su oni sudari kod kojih se energija sustava gubi zbog različitih razloga (deformacija tijela u sudaru, toplina i sl.). Budući da u realnom sudaru najčešće dolazi djelomičnog gubitka energije, ima smisla ukazati i na tu problematiku\cite{9}. Analiza takvog sudara i dalje se temelji na zakonima očuvanja. Kod elastičnih sudara u zatvorenom sustavu nalaze se sva tijela masa $m_{1}$ i $m_{2}$ koja se gibaju brzinama $v_{1}$ i $v_{2}$ prije sudara, odnosno brzinama $v'_{1}$ i $v'_{2}$ poslije sudara\cite{9}.
\subsection{Sudari bez gubitka energije} \label{subsec:no_energy}
U prvom i najosnovnijem slučaju, razmotrili smo situaciju gdje nema nikakvog gubitka energije i gdje izlazne brzine nakon sudara ostaju jednake. Prva situacija je bila sljedeća.

\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-3,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (-3,0) to (-1,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v_{1}$};
		\draw (3,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (3,0) to (1,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v_{2}$};
		
		\end{tikzpicture}
	\end{center}
	\caption {Primjer sudara kuglica}
	\label{fig:15}
\end{figure}
Kuglice se kreću jedna prema drugoj, jedan se kreće brzinom $v_{1}$, a druga brzinom $v_{2}$. U trenutku sudara, kuglice će se odbiti jedna od druge i nastaviti se kretati brzinom $v'_{1}$ tj. $v'_{2}$.
\newline
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-1.5,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (-1.5,0) to (-3.5,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v'_{1}$};
		\draw (1.5,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (1.5,0) to (3.5,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v'_{2}$};
		
		\end{tikzpicture}
	\end{center}
	\caption {Smjer gibanja kuglica nakon sudara}
	\label{fig:15-1}
\end{figure}
Nakon sudara vrijediti će sljedeće:
\begin{itemize}
	\item $v'_{1}$ = -$v_{1}$
	\item $v'_{2}$ = -$v_{2}$
 
\end{itemize}
Ovakav slučaj je trivijalan i nije problem odrediti smjer kretanja kuglica nakon sudara. Kretanje kuglica je samo u jednoj dimenziji te ukoliko pomnožimo brzinu kretanja kuglice sa (-1) dobiti ćemo rezultatnu brzinu nakon sudara.

Sljedeća situacija je kompliciranija. Kretanje jedne kuglice se događa u 2 dimenzije i to sada dodatno komplicira stvari. Situacija izgleda ovako:
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-1.5,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (-1.5,0) to (1,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v_{1}$};
		\draw (3.5,-2) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (3.5,-2) to (1.5,-0.5) node[minimum size = 1pt, xshift = 0.2 cm, yshift = -0.5cm]{$v_{2}$};
		
		\end{tikzpicture}
	\end{center}
	\caption {Primjer sudara kuglica u 2 dimenzije}
	\label{fig:16}
\end{figure}
Primjetimo kako se druga kuglica, koja se giba brzinom $v_{2}$, giba u 2 dimenzije (ima komponentu brzine u X smjeru i komponentu brzine u Y smjeru). Pretpostavimo da su mase kuglica jednake i da se pri njihovom sudare neće izgubiti nikakva energija. Rezultirajući vektori brzina više neće biti samo invertirani. Kuglica koja se giba samo po X osi (brzinom $v_{1}$) nakon sudara dobiti će i neku svoju Y komponentu brzine.
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-0.35,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (-0.35,0) to (-2.5,1.5) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm,red]{$v'_{1}$};
		\draw (2.5,-1) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (2.5,-1) to (4.5,0.5) node[minimum size = 1pt, xshift = 0.2 cm, yshift = -0.5cm,red]{$v'_{2}$};
		
		\end{tikzpicture}
	\end{center}
	\caption {Smjer gibanja kuglica nakon sudara u 2 dimenzije}
	\label{fig:17}
\end{figure}
Pretpostavimo da su i brzine kuglica u X smjeru jednake, pa će rezultat sudara približno jednak kao na slici \ref{fig:15}. Ovakav rezultat sudara možemo prikazati u nekoliko matematičkih koraka\cite{2}.

Prvo pronađemo vektor normale. To je vektor čije su komponente razlika između koordinata centara kuglica. Sukladno tome odmah pronađemo vektor tangente te oba vektora pomoću klase \emph{Vector3D} normaliziramo (kako je već i spomenuto pomoću ove klase puno nam je lakše pronaći vektor normale i tangente)\cite{2}.

\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-0.35,0) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (-0.35,0) to (2.5,-1) node[minimum size = 1pt, xshift = 0.2 cm, yshift = 0.35cm,red, scale = 0.7]{Vektor normale};
		\draw (2.5,-1) circle (1.5);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,blue] (0.4,-2) to (1.76,1) node[minimum size = 1pt, xshift = 0.2 cm, yshift = 0.35cm,blue, scale = 0.7]{Vektor tangente};

		\end{tikzpicture}
	\end{center}
	\caption {Vektor normale i tangente}
	\label{fig:18}
\end{figure}
Nakon toga, inicijalne brzine $v_{1}$ i $v_{2}$ pomnožimo sa jediničnim vektorima normale i tangente\cite{2}. Pomnožiti u ovome slučaju znači izračunati skalarni produkt između 2 vektora.
\begin{equation}\label{equ:dot_vector}
\begin{aligned}
		v'_{1,2}n = un\  v_{1,2} \\
		v'_{1,2}t = ut\ v_{1,2}
	\end{aligned}
\end{equation}
gdje nam je:
\begin{itemize}
	\item $un$ - jedinični vektor vektora normale
	\item $ut$ - jedinični vektor vektora tangente
	\item $v_{1,2}$ - vektori brzine kuglica
	\item $v'n$ - rezultirajuća brzina u smjeru normale
	\item  $v't$ - rezultirajuća brzina u smjeru tangente
\end{itemize}
Tangencijalne brzine nakon sudara ostaju jednake što znači da smo u smjeru tangente izračunali brzinu\cite{2}. Nakon što smo odradili sve ove korake, pomoću jednostavne formule izračunamo rezultatne brzine za obje kuglice prema formuli:
\begin{equation}\label{equ:final_vec}
	\begin{aligned}
		v'_{1} = v'_{2}n \ un + v'_{1}t \ ut \\
		v'_{2} = v'_{1}n \ un + v'{_2}t \ ut
		\end{aligned}
\end{equation}
S ovim jednostavnim matematičkim koracima dobiti ćemo točno odbijanje kuglica nakon sudara kako je i prikazano na slici \ref{fig:17}. Ovo se može opisati i jednostavnim algoritmom koji je prikazan na idućoj strani.
\newpage
\begin{algorithm}
	\caption{Algoritam za izračunavanje smjera brzina nakon sudara između 2 kuglice}
	\label{alg:resolve_collision_1}
	\begin{algorithmic}
		\Function {resolveCollison}{$Ball$ $a$, $Ball$ $b$}
			\If {Collision($a ,b$) is false}
			\Return
			\EndIf
			\State $normal = (a.center - b.center)$
			\State $un = unitVector(normal)$
			\State $ut(-un.y,un.x)$
			\State $v_{1}n = a.v$  $un$
			\State $v_{1}t = a.v$ $ut$
			\State $v_{2}n = b.v$ $un$
			\State $v_{2}t = b.v$ $ut$
			\State $a.v = v_{1}n$ $un + v_{1}t$ $ut$
			\State $b.v = v_{2}$ $un + v_{2}t$ $ut$
		\EndFunction
	\end{algorithmic}
\end{algorithm}\
Nakon pokretanja animacije primjećuje se jedan problem. Kuglice se slobodno gibaju po sceni i te u vrlo kratkom periodu izađu iz našeg viewporta. Našu scenu sada moramo ograničiti i to sa 4 strane s obzirom da još nismo implementirali gravitaciju. Za to će nam poslužiti klasa \emph{Wall} koju ćemo opisati u sljedećem poglavlju.

\subsection{Zidovi i klasa Wall}
Ova klasa služi za implementaciju granica tj. koji će ograničiti kretanje kuglica. Ove zidove nećemo vidjeti. Oni su nevidljivi i nalaze se na samim rubovima prozora i ovise o \emph{lookAt} vektoru. \emph{LookAt} vektor je vektor koji služi za pozicioniranje kamere na sceni. Na primjer:\newpage
\begin{lstlisting}[style=myC++, label = {code:10}, caption={Primjer lookAt vektora iz glm knjižnice}]
glm::mat4 View = glm::lookAt(
	glm::vec3(0, 0, 50), // Camera is at (0,0,50), in World Space
	glm::vec3(0, 0, -1), // and looks at the origin
	glm::vec3(0, 1, 0)   // Head is up (set to 0,-1,0 to look upside-down)
	);
}
\end{lstlisting}
Prva linija govori gdje smo na sceni postavili kameru. To znači da se kameri nalazi na koordinatama (0,0,50) (udaljeni smo samo u Z smjeru). X koordinata, dakle je u rasponu od [-25, 25], a Y u rasponu od [-20,20] (razlog ovome je $Aspect ratio$ koji je 4:3, no u ovome poglavlju to nije bitno).

Zidovi su zamišljeni kao obični AABB-i s kojima kuglice provjeravaju sudar. Kako je već spomenuto u poglavlju \ref{sec:balls} kuglice imaju pridodijeljen odgovarajući AABB, pa te objekte možemo iskoristiti za detekciju sudara između zida i kuglice. Ovdje će se također događati neke pogreške prilikom detekcije no to u principu nije bitno. Ovdje pogreška neće toliko utjecati na kretanje kuglice koliko bi u slučaju sudara između 2 kuglice. Zidovi također imaju pridodijeljen objekt klase \emph{Vector3D}, a u njemu nam je zapisana normala zida. Normala zida je vrlo bitna za izračun sudara kuglice i zida. Važno je naglasiti da je normala jedinični vektor.

\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-4,0) -- (4,0);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (0,0) to (0,2) node[minimum size = 1pt, xshift = 0.2 cm, yshift = 0.2cm,red, scale = 0.7]{Vektor normale};
		\end{tikzpicture}
	\end{center}
	\caption {Prikaz jednog zida i normale na zid}
	\label{fig:19}
\end{figure}
Zid ima AABB iste reprezentacije kao što imaju i kuglice, dakle radijus i centar.  Vertikalni zidovi imali su Y koordinatu centra 0, a horizontalni zidovi su imali X koordinatu 0. Zatim je trebalo je odrediti radijus. Zidovi koji su vertikalni, imali su samo Y komponentu radijusa, dok su horizontalni imali samo X koordinatu radijusa. Primjer je u 2D, no logika i analogija je ista u sve 3 dimenzije. Samo bi dodali još 2 zida koji nam ograničavaju Z os.
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw[red] (-3,-2) rectangle (3,2);
		\tkzInit[xmax=4,ymax=4,xmin=-4,ymin=-4]
		\tkzAxeXY
		\end{tikzpicture}
	\end{center}
	\caption {Prikaz zidova u koordinatnom sustavu}
	\label{fig:20}
\end{figure}

S obzirom na prethodno rečeno, implementacija same klase je trivijalna. Ona je prikazana na idućoj strani.
\newpage
\begin{lstlisting}[style=myC++, label = {code:11}, caption={Implementacija klase Wall}]
class Wall {
public:
	AABB_box bBox;
	Vector3D vecDir;

	Wall() = default;
	Wall(const Point center, const float rX, const float rY, const float rZ,
		const float vecX, const float vecY, const float vecZ, const float m);
	Wall(const float x, const float y, const float z, const float rX,
		const float rY, const float rZ, const float vecX, const float vecY,
		const float vecZ, const float m);
	const float &x() const { return this->center.x; }
	const float &y() const { return this->center.y; }

	const float &z() const { return this->center.z; }
	const float &getMass() const { return this->mass; }
	Point &getCenter() { return this->center; }

private:
	Point center;
	float r[3];
	float mass;
	unsigned int i;
};

\end{lstlisting}
U klasi nema metoda, osim \emph{Get}, koje nam služe za dohvaćanje pojedinih privatnih varijabli. Među varijablama nalazi se i \emph{mass} što definira masu zida. Ovoj varijabli pridodali smo vrlo veliku vrijednost, i nju ćemo kasnije koristiti za elastične sudare između zida i kuglica. 
\subsection{Sudari kuglica i zida}
Nakon implementacije klase koje nam definiraju zidove, same sudare nije problem izračunati. U počeku nismo htjeli da se gubi energija kuglica. Sada će do izražaja dolazi važnost normale zida. Htjeli smo da se kuglice odbije od zida pod istim kutom pod kojim se i sudarila. Ovakvim definiranjem normala, izbjegli smo korištenje trigonometrije i izračune upadnih i izlaznih kuteva.
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-2,2) circle (1);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,blue] (-2,2) to (0,0) node[minimum size = 1pt, xshift = -1.7 cm, yshift =0.5cm,blue, scale = 0.7]{Smjer kretanja};
		\draw (-4,0) -- (4,0);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (0,0) to (0,2) node[minimum size = 1pt, xshift = 0 cm, yshift = 0.2cm,red, scale = 0.7]{Vektor normale};
		\draw [dashed](2,2) circle (1);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,blue,dashed] (0,0) to (2,2) node[minimum size = 1pt, xshift = 1.2cm,yshift =-1.5cm,blue, scale = 0.7]{Smjer kretanja nakon odbijanja od zida};
		\end{tikzpicture}
	\end{center}
	\caption {Reakcija kuglice na sudar sa zidom}
	\label{fig:21}
\end{figure}
Ovakav tip sudara možemo prikazati formulom:
\begin{equation}\label{equ:wall_collision}
		\begin{aligned}
			vector = vector - 2Dot(vector, normal) normal;
		\end{aligned}
\end{equation}
gdje su:
\begin{itemize}
	\item $vector$ - brzina i smjer kretanja kuglice
	\item $normal$ - normala zida
	\item $Dot$ - skalarni produkt
\end{itemize}
Ovo se također može prikazati jednostavni algoritmom koji je prikazan na sljedećoj stranici.\newpage
\begin{algorithm}
	\caption{Algoritam za izračunavanje smjera kretanja kuglice nakon sudara sa zidom}
	\label{alg:resolve_Wallcollision}
	\begin{algorithmic}
		\Function {resolveCollison}{$Ball$ $ball$, $Wall$ $wall$}
		\If {AABBCollision($ball ,wall$) is false}
		\Return
		\EndIf
		\State $DoubleDot = 2  (ball.vector * wall.normal)$
		\State $collisionNormal = DoubleDot * wall.normal$
		\State $ball.vector = ball.vector - collisionNormal$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Animacija sada izgleda smisleno. Možemo dodati puno kuglica i testirati sudare između njih i sudare između kuglica i zidova. Prostor je ograničen i fizika odbijanja je smislena. Idući korak je dodavanje vanjske sile i gravitacije. Želimo da kuglice padaju, kao u stvarnome svijetu te realizirati padanje i odbijanje od podloge. U sljedećem poglavlju razmotrit ćemo dodavanje gravitacije na kretanje kuglica i njihovo odbijanje od podloge. U konačnici, odbijanje od podloge će biti isto. No, nakon odbijanja s kuglice trebaju imati fizikalnu reakciju na sudar. Kuglice se u stvarnom svijetu ne mogu stalno odbijati od podloge. Mora se dogoditi prijenos (u ovome slučaju gubitak) kinetičke energije što će u nekom trenutku rezultirati da se kuglice prestanu gibati. Sve ove slučajeve razmotriti ćemo u narednim poglavljima.\newpage

\section{Sila teža} 
Sila teže je sila kojom Zemlja privlači neko tijelo mase m, označavamo ju najčešće slovom G. Ta sila privlači sva tijela prema središtu Zemlje pa je stoga tu i usmjerena.
Sila teže razlog je zbog kojeg sva bića i predmeti ne odlete u Svemir, već stoje na površini Zemlje.
Kada pustimo tijelo da slobodno pada s određene visine, ono se giba ubrzanjem g koje iznosi 9.81 $\frac{m}{s\textsuperscript{2}}$ neovisno o njegovoj težini što znači da će istovremeno pasti i iznimno teško i iznimno lagano tijelo ukoliko ih bacimo s iste visine. To je sila kojom predmet djeluje na vodoravnu podlogu na koju je položen, npr. knjiga na stol, ili uteg na nit na koju je obješen.
Sila teža i težina jednake su po iznosu i smjeru djelovanja, ali nisu identični pojmovi.

\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (0,3) circle (1);
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (0,3) to (0,1) node[minimum size = 1pt, xshift = -1.7 cm, yshift =0.5cm,red, scale = 0.7]{Smjer djelovanja sile teže};
		\draw (-4,0) -- (4,0);

		\end{tikzpicture}
	\end{center}
	\caption {Djelovanje sile teže}
	\label{fig:22}
\end{figure}

Programski, ovo je jednostavno realizirati. S obzirom da je sila teža vertikalna sila, ona će djelovati samo na Y komponentu brzine kuglice. Opća formula sile teže glasi:
\begin{equation} \label{equ:sila_teza}
	\begin{aligned}
		G = m \ g
	\end{aligned}
\end{equation}
gdje je:
\begin{itemize}
	\item $m$ - masa objekta
	\item $g$ - akceleracija sile teže koja iznosi 9.81 $\frac{m}{s\textsuperscript{2}}$
\end{itemize}
Ovo je samo formula sile i ona nam u ovom slučaju nije korisna. S obzirom da baratamo samo sa silama moramo iskoristiti drugu fizikalnu veličinu kojom ćemo regulirati brzinu da simuliramo silu težu. 

Fizikalna veličina koju trebamo je slobodni pad. Brzina slobodnog pada iznosi:
\begin{equation}\label{slobodni_pad}
	\begin{aligned}
		v = g \ t
	\end{aligned}
\end{equation}
Slobodni pad je gibanje tijela isključivo pod utjecajem sile teže Slobodnoi pad je prijeđeni put s proporcionalan kvadratu protekloga vremena t, a brzina v jednoliko raste s proteklim vremenom, te da gibanje ne ovisi o masi tijela koje pada \cite{10}.Uobičajeno je da se slobodni pad uzima kao primjer jednolikog ubrzanog gibanja (gibanja sa stalnim ubrzanjem). Pritom se pretpostavlja da nema otpora zraka ili trenja \cite{10}.

Sama implementacija slobodnog pada je trivijalna:
\begin{algorithm}
	\caption{Algoritam za implementaciju slobodnog pada}
	\label{alg:free_fall}
	\begin{algorithmic}
		\Function {updateBallPosition}{$Ball$ $ball$, $time$ $dt$}
		\State $ball.x += ball.vector.x * dt$
		\State $ball.y += ball.vector.y * dt - 9.81 * dt$
		\State $ball.z += ball.vector.z * dt$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

U algoritmu \ref{alg:free_fall} $dt$ (delta time) nam označava vrijeme koje je dobiveno između 2 framea. Na primjer, ukoliko imamo 60 sličica po sekundi, dt nam iznosi 16.6667 ms. Dobivanje razlike vremena između 2 framea je vrlo jednostavno. U nastavku ćemo prikazati implementaciju funkcije koja nam omogućuje izračunavanje proteklog vremena i kretanje kuglica po prostoru. \newpage
\begin{lstlisting}[style = myC++, label = {code:12}, caption = {Implementacije update funkcija}]

void Ball::updatePosition(float dt) {
double acc = -9.81;
this->vecDir.setY(this->vecDir.y() + acc * dt);
this->center.x += this->vecDir.x() * dt;
this->center.y += this->vecDir.y() * dt;
this->center.z += this->vecDir.z() * dt;
}

void update(int) {
nt = glutGet(GLUT_ELAPSED_TIME) / 1000.0f; //new time
dt = nt - ot; //delta time = new time - old time
ot = nt; //old time = new time

for (uint i = 0; i < balls.size(); i++) {
balls[i].updatePosition(dt);
}

glutPostRedisplay();
glutTimerFunc(16, update, 0);
}
\end{lstlisting}

Funkcija \emph{glutGet(\texttt{GLUT\_ELAPSED\_TIME})} će nam vratit broj milisekudni koje su prošle od \emph{glutInit} poziva (koji se stalno poziva na početku main petlje). Funkcija \emph{glutTimerFunc} će nam odrediti najmanji broj milisekundi koji će proći do idućeg poziva Update funkcije.

Stvari s gravitacijom gledane na ovakav način su zapravo jasne. Na ovakav način možemo dodati bilo koju vanjsku silu koja će djelovati na kuglice. Iduće što želimo je da kuglice prilikom sudara prenose energiju. To će biti dodatno objašnjeno u idućem poglavlju.\newpage
\section{Elastični sudari}
U svim poglavljima do sada stalno se spominjala nekakva fizikalna reakcija kuglice na sudar. Svaka kuglica prilikom svog kretanja ima nekakvu kinetičku energiju. Opća formula kinetičke energije glasi:
\begin{equation}\label{equ:kinetic}
	\begin{aligned}
	E_{k} = \frac{m \ v^2}{2}
	\end{aligned}
\end{equation}
gdje je:
\begin{itemize}
	\item $m$ - masa kuglice 
	\item $v$ - brzina kuglice
\end{itemize}
Prilikom sudara između 2 kuglice, dio kinetičke energije će se izgubiti, tj. prijeći će u iz jedne kuglice na drugu i obrnuto. S obzirom da vrijedi ZAKON OČUVANJA ENERGIJE, zbroj energije 2 kuglice se neće promijeniti. Zakon očuvanja energije nam govori da u u zatvorenom sustavu zbroj svih oblika energije (mehaničke, toplinske, električne, magneske,...) konstantan. Drugim riječima, u zatvorenom sustavu jedan oblik energije može prelaziti u druge oblike, a da se pri tom energija niti stvara niti poništava\cite{11}.

Iduća fizikalna pojava koju ćemo analizirati je količina gibanja. Količina gibanja ili zalet (oznaka p) je vektorska fizikalna veličina u klasičnoj mehanici koja opisuje gibanje čestice ili sustava čestica\cite{12}:
\begin{equation}\label{equ:impuls}
\begin{aligned}
	p = m \ v
\end{aligned}
\end{equation}
gdje je:
\begin{itemize}
	\item $m$ - masa čestice
	\item $v$ - brzina čestice
\end{itemize}
Svaka kuglica koja se na sceni kreće, imati će količinu gibanja. Prilikom sudara količina gibanja količina gibanja jedne kuglice prenijeti će se na drugu kuglicu i obrnuto. Slično, kao i kod zakona o očuvanju energije, zakon očuvanja količine gibanja nam govori da količina gibanja izoliranog sustava je konstantna, odnosno, ukupna promjena količine gibanja u vremenu unutar izoliranog sustava jednaka je nuli\cite{12}.

Sada kada smo objasnili 2 važna fizikalna zakona, možemo definirati što je to elastični sudar zapravo. Kako smo i ranije rekli, elastični sudar je sudar tijela ulaze nekom brzinom $v_{1}$ i $v_{2}$, a izlazna brzina iz sudara im je $v'_{1}$ i $v'_{2}$. Kombinirajući zakon o očuvanju energije i zakon o očuvanju količine gibanja možemo reći slijedeće. Ukupna energija i ukupna količina gibanja prilikom sudara se ne mijenjaju, ali energija i količina gibanja određene kuglice se mijenja\cite{13}. Pokažimo to na jednom jednostavnom primjeru.
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-3,0) circle (1.5) node[xshift = -1.5cm, yshift = 1.5cm]{$m_{1}$};
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (-3,0) to (-1,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v_{1}$};
		\draw (3,0) circle (1) node[xshift = 1cm, yshift = 1cm]{$m_{2}$};
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt] (3,0) to (1,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm]{$v_{2}$};
		
		\end{tikzpicture}
	\end{center}
	\caption {Primjer sudara kuglica različite mase i brzine}
	\label{fig:23}
\end{figure}
\newline
gdje je:
\begin{itemize}
	\item $m_{1}$ \textgreater$m_{1}$
	\item $v_{1}$ \textgreater $v_{2}$
\end{itemize}
S obzirom na mase i brzine možemo reći sljedeće. Kuglice će se nastaviti gibati u suprotnim smjerovima. Brzina $v_{1}$ će se smanjiti s obzirom da je masa te kuglice veća. Brzina $v_{2}$ će se povećati i kuglica će se kretati u suprotnom smjeru s većom brzinom.\newpage
\begin{figure}[!http]
	\begin{center}
		\begin{tikzpicture}
		\draw (-3,0) circle (1.5) node[xshift = -1.5cm, yshift = 1.5cm]{$m_{1}$};
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (-3,0) to (-5,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm,red]{$v'_{1}$};
		\draw (3,0) circle (1) node[xshift = 1cm, yshift = 1cm]{$m_{2}$};
		\draw[-{>[scale=3.5,length=2,width=3]},line width=0.4pt,red] (3,0) to (6,0) node[minimum size = 1pt, xshift = -0.1 cm, yshift = 0.35cm,red]{$v'_{2}$};
		
		\end{tikzpicture}
	\end{center}
	\caption {Primjer sudara kuglica različite mase i brzine}
	\label{fig:24}
\end{figure} 
Iako su se brzine promijenile, ukupna količina gibanja ostala je jednaka. Sukladno tome vrijedi:
\begin{equation}\label{equ:kol_gib}
	m_{1}  v_{1} + m_{2} v_{2} = m_{1}  v'_{1} + m_{2}  v'_{2}
\end{equation}
Ukupna količina energije ostaje jednaka pa vrijedi i:
\begin{equation}\label{equ:kol_energ}
\frac{1}{2}  (m_{1}  v_{1}^2 + m_{2}  v_{2}^2) = \frac{1}{2}  (m_{1}  v_{1}'^2 + m_{2}  v_{2}'^2)
\end{equation}
gdje su u obje jednadžbe:
\begin{itemize}
	\item $m_{1}$, $m_{2}$ - mase kuglica
	\item $v_{1}$, $v_{2}$ - brzine kuglica prije sudara
	\item $v'_{1}$, $v'_{2}$ - brzine kuglica nakon sudara
\end{itemize}
Nakon niza matematičkih operacija i skraćivanja izraza možemo donijeti konačne izraze koji će nam izračunati brzine kuglica nakon sudara. Oni glase\cite{13}:
\begin{equation}\label{equ:elastic_coll}
	\begin{aligned}
		v'_{1} = \frac{v_{1}  (m_{1} - m_{2}) + 2  m_{2} v_{2}}{m_{1} + m_{2}}\\
		v'_{2} = \frac{v_{2}  (m_{2} - m_{1}) + 2  m_{1} v_{1}}{m_{1} + m_{2}}
	\end{aligned}
\end{equation}
Ovi sudari vrijede samo za 1 dimenziju, ali to je u redu\cite{13}. Prema onome što je ranije navedeno u poglavlju \ref{subsec:no_energy} nama i trebaju samo 1 dimenzionalni sudari. Ranije u poglavlju \ref{subsec:no_energy} opisane su jednadžbe kojima dobivamo smjer kretanja kuglica nakon sudara bez prijenosa količine energije i količine gibanja. U ovome poglavlju, objašnjeno kako će se ponašati samo vrijednosti brzina nakon sudara. Sada samo treba izvesti, ove 2 jednadžbe iz jednadžbe \ref{equ:elastic_coll} dodati u kod za rješavanje sudara kuglica. Prema algoritmu \ref{alg:resolve_collision_1} možemo iznijeti slijedeći algoritam za to:\newline
\begin{algorithm}
	\caption{Algoritam za izračunavanje smjera i iznosa brzina sudara između 2 kuglice uz promjenu količine gibanja jedne kuglice}
	\label{alg:resolve_collision_2}
	\begin{algorithmic}
		\Function {resolveCollison}{$Ball$ $a$, $Ball$ $b$}
		\If {Collision($a ,b$) is false}
		\Return
		\EndIf
		\State $normal = (a.center - b.center)$
		\State $un = unitVector(normal)$
		\State $ut(-un.y,un.x)$
		\State $v_{1}n = a.v$ $un$
		\State $v_{1}t = a.v$  $ut$
		\State $v_{2}n = b.v$  $un$
		\State $v_{2}t = b.v$  $ut$
		\State $v_{1}(x,y,z) = \frac{v_{1}n  (m_{1} - m_{2}) + 2  m_{2} v_{2}n}{m_{1} + m_{2}}$
		\State $v_{2}(x,y,z) = \frac{v_{2}n  (m_{2} - m_{1}) + 2  m_{1} v_{1}n}{m_{1} + m_{2}}$
		\State $a.v = v_{1}$  $un + v_{1}t$  $ut$
		\State $b.v = v_{2}$  $un + v_{1}t$  $ut$
		\EndFunction
	\end{algorithmic}
\end{algorithm}\

Ovime smo zaokružili cjelinu o kretanjima i sudaranjima kuglica. Ipak, problem je to što nam je sama detekcija sudara između svih kuglica prespora. Kako smo opisali ranije u poglavlju 2, postoje algoritmi za ubrzavanja same detekcije sudara. U narednim poglavljima cilj je opisati algoritam s kojim smo na zadovoljavajući način detektirali sve sudare na sceni i prema gore navedenim jednadžbama, iste sudare izračunali.

