\chapter{Sjenčanje}
U fazi sjenčanja, ujedno i posljednjoj fazi ovoga rada, cilj je bio dodati atribute kuglicama kako bi rad izgledao impresivnije. Prije samog korištenja alata za sjenčanje (tzv. Shader) bilo je potrebno promijeniti okolinu u kojoj se rad izvršavao. Do sada, koristili smo OpenGL 1.x, koji je eksperimentalan i ne koristi Shadere za iscrtavanje poligona. S OpenGL-a 1.x, smo iz tog razloga prešli na noviju verziju, OpenGL 3.3 koji nam omogućava korištenje Shadera i nekih naprednijih opcija koje nismo do sada imali.

Iako je noviji, OpenGL 3.3 koristi neke nove principe i modele s kojima se do sada nismo susreli. Zbog toga, morali smo odustati od \emph{GLUT-a}, koji nam je služio za komunikaciju sa operacijskim sustavom (prikaz prozora, korištenje miša i tipkovnice, terminiranje prozora,...). Prešli smo na noviji \emph{GLFW} koji se koristi kod modernijih verzija OpenGL-a. U principu \emph{GLFW} i \emph{GLUT} služe za iste stvari, no \emph{GLFW} je moderniji i pruža nam bolju optimizaciju programa nego stariji \emph{GLUT}. Usprkos tome, \emph{GLFW} nema biblioteke za crtanje sfera, pravokutnika i sl. pa smo morali sami definirati sferu kojom ćemo opisati kuglice. To će biti objašnjeno u narednom poglavlju.
\newpage
\section{Crtanje sfere}
Kako smo spomenuli \emph{GLFW} nema biblioteke kojima možemo nacrtati jednostavne poligone kao što ima \emph{GLUT}. Dakle, do sada korištena funkcija \emph{glutSolidSphere} za crtanje kuglica, više nam nije bilo od koristi i morali smo definirati sami točke kojima ćemo crtati sferu.

Za crtanje sfere postoje generalno 2 načina:
\begin{itemize}
	\item Programsko generiranje točaka, indeksa i normala
	\item Prijenos objekta iz odgovarajućeg formata generiranog u programu za crtanje modela (npr. Blender)
\end{itemize}
U početku je bila velika dilema koji od ova 2 načina odabrati, s obzirom da je svaki od njih imao neke svoje prednosti i mane, no u konačnosti izabrali smo programsko generiranje zbog relativno lakšeg implementiranja od prijenosa objekata. Inače, prijenos objekata iz nekog drugog alata nije sam po sebi težak, no ili zahtjeva dodatne biblioteke (npr. Assimp) ili zahtjeva pisanje programa koji će preuzeti podatke iz formata i postaviti ih u polja koja iscrtavamo.

Kako smo rekli, OpenGL 3.3 za crtanje objekata koristi Shadere. Bez Shadera na sceni nećemo vidjeti ništa, te su oni ti koje objekte prikazuju. Shadere je potrebno posebno kompilirati i to za sada nećemo ovdje prikazivati, nego u kasnijim poglavljima. Za početak koristili smo jednostavne Shadere. Shadere dijelimo na Shadere točaka i Shadere fragmenata\cite{15}. Trenutno nećemo ulaziti u analizu kodova nego ćemo samo prikazati Shadere. Shader točaka definiran je:
\begin{lstlisting}[style = myC++, label = {code:14}, caption = {Jednostavni Shader točaka}]
#version 330 core
layout(location = 0) in vec3 vertexPosition;
// Values that stay constant for the whole mesh.
out vec3 fragmentColor;
void main(){
// Output position of the vertex, in clip space : MVP * position
	gl_Position.xyz =  vertexPosition_modelspace;
	fragmentColor = vertexColor;
}
\end{lstlisting}
Shader fragmenata definiran je kao:
\begin{lstlisting}[style = myC++, label = {code:15}, caption = {Jednostavni Shader fragmenata}]
#version 330 core
// Ouput data
in vec3 fragmentColor;
out vec3 color;

void main()
{
	color = vec3(0.4,0.2,0.7); 
}
\end{lstlisting}

U početku, bilo je vrlo teško krenuti od crtanja same sfere. Trebalo je prvo razumjeti sve strukture koje se koriste u OpenGL-u 3.3 pa smo krenuli prvo od crtanja običnog trokuta korištenjem spomenutih Shadera.

\subsection{Crtanje trokuta}
Crtanje trokuta je prvi korak pri učenju OpenGL-a 3.3 \cite{15}\cite{16}. Na ovom jednostavnom primjeru, mogu se naučiti sve strukture i tipovi podataka koji se koriste prilikom korištenja OpenGL-a 3.3. 

Trokut možemo definirati sa 3 točke. Neka to budu točke:
\begin{itemize}
	\item (-0.5f, -0.5f, 0.0f)
	\item (0.5f, -0.5f, 0.0f)
	\item (0.0f, 0.5f, 0.0f)
\end{itemize}
Vrlo je važno da točke budu definirane točno ovim redom inače ih OpenGL 3.3 neće nacrtati kako smo to htjeli. Ove točke važno je spremiti u strukturu zvanu VBO tj. Vertex Buffer Object. Ova struktura nam omogućava crtanje objekata na grafičkoj kartici, a ne na procesoru\cite{16}. Prije VBO-a definirali smo i Vertex Array Object, no ovdje on nije posebno bitan pa ga nećemo posebno ni spominjati. U nastavku slijedi kod kojime smo generirali VBO i u njega poslali podatke o točkama trokuta\cite{15}.\newpage
\begin{lstlisting}[style = myC++, label = {code:15}, caption = {Generiranje VBO\cite{16}}]
static const float vertices[] = {-0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f,}; //vertices of triangle
	  
unsigned int VBO;
glGenBuffers(1, &VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	  
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);
glEnableVertexAttribArray(0);
glBindBuffer(GL_ARRAY_BUFFER, 0);
\end{lstlisting}
Samo crtanje trokuta izvodi se na:
\begin{lstlisting}[style = myC++, label = {code:16}, caption = {Crtanje trokuta\cite{15}}]
do {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
	glUseProgram(Shader);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);
	glDrawArrays(GL_TRIANGLES, 0, 3); // 3 indices starting at 0 -> 1
	glfwSwapBuffers(window);
	glfwPollEvents();
}
\end{lstlisting}

Objašnjenje ovoga koda nećemo raditi, s obzirom da su to funkcije i strukture korištene isključivo sa strane OpenGL-a. Nastavak objašnjenja ovih struktura može se pronaći u \cite{15} i \cite{16}. Na ovakav način dobili smo trokut koji izgleda ovako:\newpage
\begin{figure}[!http]
	\begin{center}
		\includegraphics[height = 8 cm, width = 8 cm, keepaspectratio = true]{triangle}
		\caption{Trokut u OpenGL-u 3.3}
		\label{fig:29}
		\end{center}
\end{figure}

Idući zadatak bio je ovaj trokut pomicati po prostoru. Ovdje smo umjesto funkcija unutar OpenGL-a koristili \emph{glm} biblioteku matematičkih funkcija koja nam omogućava operacija sa matricama i transformacije u prostoru.

\subsection{Transformacije}

Prije korištenja OpenGL-a 3.3 transformacije smo definirali funkcijama unutar OpenGL-a. S obzirom da smo tada samo crtanje objekata izvršavali na procesoru, ovo je bilo moguće bez problema. Prelaskom na OpenGL 3.3 transformacije smo morali poslati u Shader da bi znali gdje nacrtati objekt.

Svaki objekt ima svoj definirani prostor koji je definiran lokalnim koordinatama\cite{16}. Lokalne koordinate svakog objekta definirane su matricom modela. Transformacijom matrice modela definiramo poziciju svakog objekta unutar cijele scene tj. svijeta. Konačno, matricom pogleda definiramo pogled na svijet tj. koordinate iz kojih imamo pogled na cijelu scenu. U konačnosti definiranjem projekcije definiramo kako ćemo vidjeti stvari na sceni ("Clip space"). Ovo možemo prikazati jednostavnim dijagramom:\newpage
\begin{figure}[!http]
	\begin{center}
		\includegraphics[height = 5 cm, width = 5 cm, keepaspectratio = true]{transformations}
		\caption{Transformacije matrica i koordinata u OpenGL-u\cite{15}}
		\label{fig:30}
	\end{center}
\end{figure}
Umnoškom:
\begin{equation}
	\begin{aligned}
		MVP = Projection Matrix * View Matrix * Model Matrix
	\end{aligned}
\end{equation}
dobili smo transformaciju točaka u prostor koji mi vidimo (ili ne vidimo)\cite{16}. Transformacijom matrice modela (Model Matrix), možemo obavljati transformacije na objektima (translacija, skaliranje, rotiranje).Jednostavnim umnoškom matrica definiramo transformacije objekta. Na primjer:
\begin{lstlisting}[style = myC++, label = {code:17}, caption = {Primjer transformacije objekata}]
glm::mat4 projection = glm::perspective(glm::radians(45.0f),(float)4 / (float)3, 0.1f, 1000.0f);
  
glm::mat4 view = glm::lookAt(
  glm::vec3(0, 0, 50), // Camera is at (0,0,50), in World Space
  glm::vec3(0, 0, -1), // and looks at the origin
  glm::vec3(0, 1, 0)   // Head is up (set to 0,-1,0 to look upside-down)
);
glm::mat4 Model = glm::mat4(1.0f);
glm::vec3 position = glm::vec3(5.0, 4.0, 0.0);
glm::vec3 radius = glm::vec3(1.0f, 1.0f, 1.0f) * 3.0f;
Model = glm::scale(Model, radius);
Model = glm::translate(Model, position);
glm::mat4 mvp = projection * view * Model;
\end{lstlisting}
Transformacije objekata moramo primjenjivati prema pravilu, prvo skaliranje, zatim rotacija i u konačnosti translacija\cite{15}. 

Kada smo na procesoru izračunali transformacijske matrice, iste je potrebno poslati u Shadere. U pravilu, sva množenja matrica potrebno je izvršavati na procesoru, no nekada se množenja matrice mogu izvršavati i na grafičkoj kartici. Ovo će biti kod nas slučaj u kasnijem dijelu crtanja same sfere radi boljeg dizajna koda. Izračunate transformacijske matrice šaljemo u Shadere pomoću ključne riječi \emph{uniform}. Unutar Shadera točaka je potrebno pomnožiti transformacijsku matricu sa svim točkama objekta, da bi dobili točno mjesto gdje ćemo nacrtati naš objekt. To se izvodi na sljedeći način:
\begin{lstlisting}[style = myC++, label = {code:17}, caption = {Primjer transformacije objekata}]
layout(location = 0) in vec3 vertexPosition_modelspace;

// Values that stay constant for the whole mesh.
uniform mat4 MVP;

void main(){
// Output position of the vertex, in clip space : MVP * position
gl_Position =  MVP * vec4(vertexPosition_modelspace,1);
}

\end{lstlisting}
Trokut sa slike \ref{fig:29} sada izgleda ovako:
\begin{figure}[!http]
	\begin{center}
		\includegraphics[height = 8 cm, width = 8 cm, keepaspectratio = true]{transformed_triangle}
		\caption{Trokut sa apliciranim transformacijama}
		\label{fig:31}
	\end{center}
\end{figure}
Iako smo trokut skaliranjem povećali, on izgleda manje iz razloga što je kamera udaljena u Z smjeru. Rotaciju ovdje nismo primjenjivali jer nam kasnije nije bila potrebna.

Razumijevanje transformacija i matrica bila je jedna od ključnih koraka prije crtanja same sfere. Sada smo mogli definirati veliki broj trokuta, koje ćemo onda crtati na sceni, a sve u nekoliko linija unutar Shadera i C++. U ovom koraku već smo mogli primijetiti da algoritam koji smo prije implementirali radi na trokutima (koji su opisani sferom). U daljnjim koracima potrebno je bilo nacrtati same sfere i definirati Shadere koji će dati sferama određena svojstva.

\subsection{Definiranje sfere}